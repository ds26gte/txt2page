ver=2014-12-14 # last modified

# ds26gte@yahoo.com

if test $# -eq 0
then echo error: no argument provided; exit;
fi

opts=""
pdf=0
soelim=0
while test $# -ne 0
do
    if test "$1" = "-s"
    then soelim=1
    elif test "$1" = "-Tpdf"
    then pdf=1
    else opts="$opts $1"
    fi
    shift
done

if test "$pdf" = 1
then exec txt2page_pdf $opts; exit
fi

txt2pageLoop() {
  prev=
  while test $# -ne 0
  do
    curr="$1"
    shift
    if test $# -ne 0
    then next="$1"
    else next=
    fi
    txt2pageEachFile "$curr" "$prev" "$next"
    prev="$curr"
  done
}

txt2pageEachFile() {
  f=$1
  prevPage=$2
  nextPage=$3
  if test ! -f "$f"
  then
    if test "$f" = "--version"
    then echo txt2page $ver; exit
    elif test "$f" = "--help"
    then echo txt2page "[-s] [-Tpdf [groff_options]] [--version|--help|<file> ...]"; exit
    else echo error: $f does not exist; exit
    fi
  else
    g=${f##*/}
    ext=${g##*.}
    if test "$ext" = "$g"
    then ext=""
    fi
    if test "$ext" = html -o "$ext" = ps -o "$ext" = pdf
    then echo error: $f is a $ext file; exit
    fi
    g=${g%.*}
    h=$g.html
    cp -p $f $h
    if test -f $g.css
    then cssf=$g.css
    elif test -f txt2page.css
    then cssf=txt2page.css
    elif test -f default.css
    then cssf=default.css
    else
      cssf=$(ls -1 .*.css *.css 2> /dev/null | head -1)
      if test -z $cssf
      then
        echo '/* insert style here */' > default.css
        cssf=default.css
      fi
    fi
    txt2pageExCommands $h
  fi
}

txt2pageExCommands() {
  ex -u NONE $1 <<EOF

func! RecognizeURLs()

    " someone@gmail.com becomes mailto:someone@gmail.com
    " -- check not already preceded by mailto:
    s#\%(mailto:\)\@<!\<[[:alnum:]]\+@[[:alnum:].]\+\.\%(ca\|com\|edu\|gov\|in\|net\|org\|us\)\>#mailto:&#g

    " evalwhen.com becomes FAKEHTTP://evalwhen.com
    " -- check not preceded by @ or ://
    s#\%(@\|://\)\@<!\<[[:alnum:].-]\+\.\%(com\|co\.[[:lower:]]\{2}\|edu\|net\|org\|se\)\>#FAKEHTTP://&#g

    " mailto:addr becomes <a href="mailto:addr">mailto:addr</a>
    s#\<mailto:\([[:alnum:]]\+@[[:alnum:].]\+[[:alpha:]]\)\>#<a href="&"><code>\1</code></a>#g

    " @twitterhandles
    s#\%([[:alnum:]]\)\@<!@\([[:alnum:]_]\{1,15}\)#*<code>@\1</code>* https://twitter.com/\1#g

    " URL becomes <a href="URL">URL</a>
    s#\<[[:alpha:]-]\+://[^[:space:]()<>\[\]]\+\%(([[:alnum:]]\+)\|/\|[^[:space:][:punct:]»]\)#<a\rÞtzpHrefTzphref="&"\r><code>&</code></a>#g

    " “./sth” becomes <a href="sth">sth</a>
    s#“\./\(.\{-}\)”#<a href="\1"><code>\1</code></a>#g

    " ./pathname becomes <a href="pathname">pathname</a>
    s#\%([.]\)\@<!\./\([^[:space:]()<>&]\+\)\%([[:punct:]]\)\@<!#<a href="\1"><code>\1</code></a>#g

    " FAKEHTTP has done its job by now -- remove it
    "s#FAKEHTTP://##g

    " :emoji:
    s#:\([a-z0-9_\-]\{1,32}\):#<img class=emoji title=":\1:" alt=":\1:" src="https://assets.github.com/images/icons/emoji/\1.png" height=20 width=20 align=absmiddle/>#g

    "images

    s#^\.\s*JPEG\s\+\([^-[:space:]]\)#.JPEG -center \1#

    s#^\.\s*JPEG\s\+-L\s#.JPEG -left #
    s#^\.\s*JPEG\s\+-C\s#.JPEG -center #
    s#^\.\s*JPEG\s\+-R\s#.JPEG -right #

    s#^\.\s*\(JPEG\s\+-[leftcnrigh]\+\s\+\S\+\)\s*\$#.\1 50#

    s#^\.\s*JPEG\s\+-\([leftcnrigh]\+\)\s\+\(\S\+\)\s\+\([0-9]\+\)#<div class=figure align=\1><img src="\2" width="\3%" border="0" alt=""></div>#

    exec 's:<a href="\(.\{-}\)\.' . g:fileExtension . '"><code>\(.\{-}\)\.' . g:fileExtension . '</code></a>:<a href="\1.html"><code>\2.html</code></a>:g'

    exec 's:<a href="\(.\{-}\)\.' . g:fileExtension . '">:<a href="\1.html">:g'

    exec 's:<a href="\(.\{-}\)\.' . g:fileExtension . '#\(.\{-}\)"><code>\%(.\{-}\)\.' . g:fileExtension . '#\(.\{-}\)</code></a>:<a href="\1.html#\2">\3</a>:g'

    s:\(<a href="#.\{-}">\)<code>#\(.\{-}\)</code>:\1\2:g

endfunc

func! CleanUpURLs()
    s/ÞtzpHrefTzphref/ href/
    s#href="FAKEHTTP://#href="http://#
    -1,+1 jo!
    s#FAKEHTTP://##g
    s:«\(<a href.\{-}/a>\)»:\1:g
endfunc

func! UpcaseDigits(x)
  let l:y = a:x
  let l:y = substitute(l:y, '0', '⁰', 'g')
  let l:y = substitute(l:y, '1', '¹', 'g')
  let l:y = substitute(l:y, '2', '²', 'g')
  let l:y = substitute(l:y, '3', '³', 'g')
  let l:y = substitute(l:y, '4', '⁴', 'g')
  let l:y = substitute(l:y, '5', '⁵', 'g')
  let l:y = substitute(l:y, '6', '⁶', 'g')
  let l:y = substitute(l:y, '7', '⁷', 'g')
  let l:y = substitute(l:y, '8', '⁸', 'g')
  let l:y = substitute(l:y, '9', '⁹', 'g')
  return l:y
endfunc

"let g:initFcounterValue = 2718
let g:initFcounterValue = 1

func! BumpFcounter(...)
  if !exists('b:FcounterValue')
    let b:FcounterValue = g:initFcounterValue - 1
  endif
  if a:0
    let b:FcounterValue = g:initFcounterValue - 1
  else
    let b:FcounterValue += 1
    return UpcaseDigits('¶' . b:FcounterValue)
  endif
endfunc

func! FindURLfootnotes()
  call BumpFcounter(0)
  v/^ÞtzpPreformattedTzp/ s_:<a href="\(.\{-}\)">.\{-}</a>_<a href="\1">ÞtzpURLfootnoteTzp</a>_g
  %s/ÞtzpURLfootnoteTzp/‣‣‣/g
  "%s/ÞtzpURLfootnoteTzp/\=BumpFcounter()
endfunc

func! FindURLHs()
  g/\%(᛫.*\)\@<!<a href="/ s/^/ÞtzpPossibleURLHtzp/

  g/^ÞtzpPossibleURLHtzp/ -1s/᛫.\{-}\$/&ÞtzpURLHcontinuationLineTzp/

  %s/^ÞtzpPossibleURLHtzp//

  g/ÞtzpURLHcontinuationLineTzp\$/ .,+1 j

  %s/ÞtzpURLHcontinuationLineTzp//

  " ***

    " a line that starts with <a href is a possible urlh
    %s/^<a href/ÞtzpPossibleURLHtzp&/

    " its previous line could contain the link text
    g/^ÞtzpPossibleURLHtzp/ -1s/⋆\$/&ÞtzpURLHcontinuationLineTzp/

    %s/^ÞtzpPossibleURLHtzp//

    " unite link text and url
    g/ÞtzpURLHcontinuationLineTzp\$/ .,+1 j

    %s/ÞtzpURLHcontinuationLineTzp//

    " ***

    " a line that contains an unmatched * followed by <a href is a possible urlh
    v/^ÞtzpPreformattedTzp/ s/^[^⋆*]\+[⋆*]\s\+<a href/ÞtzpPossibleURLHtzp&/

    " if its previous line contains a *, it contains (part of) the link text
    g/^ÞtzpPossibleURLHtzp/ -1s/[⋆*].\{-}\$/&ÞtzpURLHcontinuationLineTzp/

    %s/^ÞtzpPossibleURLHtzp//

    " unite link text and url
    g/ÞtzpURLHcontinuationLineTzp\$/ .,+1 j

    %s/ÞtzpURLHcontinuationLineTzp//

    " ***

    " a line containing no [ preceding a ](<a href= is a possible urlh
    v/^ÞtzpPreformattedTzp/ s/^[\[]\+\](<a href=/ÞtzpPossibleURLHtzp&/

    " if its prev line contains a [, it contains (parf of) the link text
    g/^ÞtzpPossibleURLHtzp/ -1s/\[.\{-}\$/&ÞtzpURLHcontinuationLineTzp/

    %s/^ÞtzpPossibleURLHtzp//

    " unite link text and url
    g/ÞtzpURLHcontinuationLineTzp\$/ .,+1 j

    %s/ÞtzpURLHcontinuationLine//

    " replace previous link text with true link text

    v/^ÞtzpPreformattedTzp/ s#᛫\s*\(.\{-}\)\s*<a href="\(.\{-}\)">.\{-}</a>#<a href="\2">\1</a>#g

    v/^ÞtzpPreformattedTzp/ s#[⋆*]\([^⋆*]\+\)[⋆*]\s*<a href="\(.\{-}\)">.\{-}</a>#<a href="\2">\1</a>#g

    v/^ÞtzpPreformattedTzp/ s#\[\([^\[\]]*\)\](<a href="\(.\{-}\)">.\{-}</a>)#<a href="\2">\1</a>#g

endfunc

func! RedirectIfNecessary()
  v/^ÞtzpPreformattedTzp/ s#<a href="\(.\{-}\)">=REDIRECT=</a>#ÞtzpRedirectTzp{\1}#
  let redirectFoundP = 0
  g/ÞtzpRedirectTzp{.\{-}}/ let redirectFoundP = 1
  if redirectFoundP
    /ÞtzpRedirectTzp/
    norm f{lyi}
    let g:redirectURL = @0
    g/ÞtzpRedirectTzp{.\{-}}/ s#ÞtzpRedirectTzp{\(.\{-}\)}#If not redirected automatically, go to <a href="\1">\1</a>.#
  endif
endfunc

func! Toggle01(...)
  if a:0
    let b:toggle01Value = 1
  else
    let b:toggle01Value = !b:toggle01Value
    return b:toggle01Value
  endif
endfunc

func! VerbatimLineAsIsWithContinuation()
  s/\s/Ø/g
  s/^[^Ø]/ÞtzpVerbatimContinuationTzp&/
  s/^Ø//
  s/\([^Ø]\)Ø\([^Ø]\)/\1 \2/g
  s#\$#<br/>#
endfunc

func! VerbatimLineAsIs()
  s/^\$/Ø/
  s/\s/Ø/g
  s/\([^Ø]\)Ø\([^Ø]\)/\1 \2/g
  s#\$#<br/>#
endfunc

func! CodeLineAsIs()
  call VerbatimLineAsIs()
  s/^/ÞtzpPreformattedTzp/
endfunc

func! Txt2page()

while 1
  if (!$soelim)
    %s/^\.\s*so\s\+\(\S\+\s\+\S\)/ÞtzpSoTOCtzp \1/
  endif
  0
  let m = search('^\.\s*so\s')
  if (m == 0)
    break
  endif
  s/^\.\s*so/ÞtzpSoDoneTzp/
  norm W
  r <cfile>
endwhile

g/^ÞtzpSoDoneTzp/d

"use unabbreviations for these rare characters if they occur verbatim in the source,
"as we'll be using these characters as temporary symbols

%s/Þ/ÞtzpThornTzp/g
%s/^ÞtzpThornTzp\(tzpSoTOCtzp\)/Þ\1/  "! see above
%s/Ø/ÞtzpOslashTzp/g
%s/Æ/ÞtzpAEligTzp/g
%s/«/ÞtzpLangleLangleTzp/g
%s/»/ÞtzpRangleRangleTzp/g

\$a
ÞtzpBogusEndOfFileLineTzp
.

"use temp symbols to stand for verbatim &<>; we'll convert them to appropriate HTML entities
"at the end

%s/&/Æ/g
%s/</«/g
%s/>/»/g

"remove all trailing spaces

%s/\s\+\$//

let titleText = "$g"
let fileStem = "$g"

let g:fileExtension = "$ext"
if g:fileExtension == ""
    let g:fileExtension = "tzpLetsNotMatchAnythingAgainstThis"
endif

0
let lastline = line('$')
while 1
    let linenum = line('.')
    if linenum > 100 || linenum == lastline
        break
    endif
    let linestr = getline('.')
    if match(linestr, '^\.\s*TH\s\+".\{-}"') > -1
        s/^\.\s*TH\s\+"\(.\{-}\)".*/.TH \1/
        break
    elseif match(linestr, '^\.\s*TH\s\+\(\S\+\)\s\+\S') > -1
        s/^\.\s*TH\s\+\(\S\+\).*/.TH \1/
        break
    endif
    norm j
endwhile

let ln = 0
while ln < 100 && ln < lastline
    let x = getline(ln)
    if match(x, '^\%(\.\s*\%(TH\|SH\|SS\)\|#\+\)\s\+\S') > -1
        let titleText = substitute(x, '^\%(\.\s*\%(TH\|SH\|SS\)\|#\+\)\s\+\(.\{-}\)\s*#*\$', '\1', '')
        break
    endif
    let ln+=1
endwhile

"code display

%s/^\.\s*E[XE]\$/\`\`\`/

%s/^\s*\`\`\`\s*[[:alpha:]]\+\$/ÞtzpListingTzp scheme/
%s/^\s*\`\`\`\+$/ÞtzpListingTzp/

if executable('lisphilite')
  g/^ÞtzpListingTzp scheme/+1,/^ÞtzpListingTzp/-1 s/«/</g
  g/^ÞtzpListingTzp scheme/+1,/^ÞtzpListingTzp/-1 s/»/>/g
  g/^ÞtzpListingTzp scheme/+1,/^ÞtzpListingTzp/-1 s/Æ/\&/g
  g/^ÞtzpListingTzp scheme/+1,/^ÞtzpListingTzp/-1 !lisphilite
endif

call Toggle01(0)
g/^ÞtzpListingTzp/ s/\$/\=Toggle01()

g/^ÞtzpListingTzp.*0\$/+1,/^ÞtzpListingTzp.*1\$/-1 call CodeLineAsIs()

%s#^ÞtzpListingTzp\(.*\)0\$#</p>\rÞtzpPreformattedTzp<div class="listing\1"><code>#
%s#^ÞtzpListingTzp\(.*\)1\$#ÞtzpPreformattedTzp</code></div>\r<p class=noindent>#

"

g/^\.\s*TOC\$/d

"

%s/^\.\s*nf\$/ÞtzpNoFillEnvTzp/
%s/^\.\s*fi\$/ÞtzpNoFillEnvTzp/

call Toggle01(0)
g/^ÞtzpNoFillEnvTzp\$/ s/\$/\=Toggle01()

if (b:toggle01Value != 1)
      \$a
  ÞtzpNoFillEnvTzp1
.
endif

g/^ÞtzpNoFillEnvTzp0/+1,/^\s*ÞtzpNoFillEnvTzp1/-1 call VerbatimLineAsIs()

g/^\s*ÞtzpNoFillEnvTzp[01]/d

0
let lastline = line('$')
while 1
  let currline = line('.')
  if currline == 1 && match(getline('.'), '^\s') > -1
    let m = 1
  else
    let m = search('^\s')
  endif
  if m == 0
    break
  endif
  s/\$/ÞtzpLeadingSpacesStartLineTzp/
  while 1
    if match(getline('.'), '^\$') > -1
      s:^\$:</p>\r<p class=noindent>:
      break
    endif
    call VerbatimLineAsIsWithContinuation()
    if line('.') == lastline
      break
    endif
    norm j
  endwhile
  g/ÞtzpLeadingSpacesStartLineTzp/ s#^#</p>\r<p class=noindent>\r#

  %s/ÞtzpLeadingSpacesStartLineTzp//

  g/^ÞtzpVerbatimContinuationTzp/-1 s:<br/>\$::

  %s/^ÞtzpVerbatimContinuationTzp//
endwhile

v/᛫/ s/^\.\s*\\\"/ÞtzpDeleteCommentTzp&/
g/^ÞtzpDeleteCommentTzp/d

"g/^\.\s*\\\"/d
"g/^\.\s*HTL/d
"g/^#\s\+.\{-}\s*##\$/d

"v/^ÞtzpPreformattedTzp/ call SmartQuotes()

"bullet items

%s:^•\s\+:</p><p class=bulleted><span class=bullet>•Ø</span>:

"Tables

"for every line starting with |\s, replace it with <space>ÞtzpTableLineTzp

g/^|\s/,/^[^|]/-1 s#^|\s# ÞtzpTableLineTzp#

"collapse successive ÞtzpTableLineTzps together

g/^ ÞtzpTableLineTzp/,/^\%(\$\|[^ ]\)/-1 j

"remove single space before ÞtzpTableLineTzp

%s/ \(ÞtzpTableLineTzp\)/\1/g

"enclose the collapsed ÞtzpTableLineTzp with <table> tags

%s#^ÞtzpTableLineTzp.*\$#</p>\r<div align=center>\r<table border="1" cellpadding="4">&\r</table>\r</div>\r<p>#

"precede each ÞtzpTableLineTzp with a CR

%s#ÞtzpTableLineTzp#\r&#g

"chomp the last | in each table line

g/^ÞtzpTableLineTzp/ s#\s|\$##

"replace every other | with a table-cell separator

g/^ÞtzpTableLineTzp/ s#\s|\s#</td><td>#g

"wrap each table-line with a <tr>

%s#^ÞtzpTableLineTzp\(.*\)\$#<tr><td>\1</td></tr>#

"g/^ÞtzpBogusEndOfFileLineTzp/d

"visible anchor
%s:^†††\s*\([^†[:space:]()<>&#]\+\)\$:<span class=anchor><a name="\1"></a>[\1]Ø</span>:

"invisible anchor
%s:^††\s*\([^†[:space:]()<>&#]\+\)\$:<a name="\1"></a>:

"sections

%s/^\.\s*TH\s\+\(.*\)\$/ÞtzpSectionTzp title \1/
%s/^\.\s*SH\s\+\(.*\)\$/ÞtzpSectionTzp 1 \1/
%s/^\.\s*SS\s\+\(.*\)\$/ÞtzpSectionTzp 2 \1/

%s/^#\s\+\(.\{-}\)\s\+#\$/ÞtzpSectionTzp title \1/
%s/^#\s\+\(.\{-}\)\s\+##\$/ÞtzpSectionTzp htmltitle \1/
"%s/^##\s\+##\$/ÞtzpSectionTzp sectionbreak x/
%s/^###\s\+###\$/ÞtzpSectionTzp dropcap x/

%s/^#\s\+\(.\{-}\)\s*#*\$/ÞtzpSectionTzp 1 \1/
%s/^##\s\+\(.\{-}\)\s*#*\$/ÞtzpSectionTzp 2 \1/
%s/^###\s\+\(.\{-}\)\s*#*\$/ÞtzpSectionTzp 3 \1/
%s/^####\s\+\(.\{-}\)\s*#*\$/ÞtzpSectionTzp 4 \1/
%s/^#####\s\+\(.\{-}\)\s*#*\$/ÞtzpSectionTzp 5 \1/
%s/^######\s\+\(.\{-}\)\s*#*\$/ÞtzpSectionTzp 6 \1/

g/^ÞtzpSectionTzp/,/./-1 j!

g/^ÞtzpSectionTzp\s\+htmltitle\s\+/d

%s:^ÞtzpSectionTzp\s\+\(title\)\s\+\(.*\):</p>\r<h1 class=\1>\2</h1>\r<p class=noindent>:
%s:^ÞtzpSectionTzp\s\+\([1-6]\)\s\+\(.*\):</p>\r<h\1 class=section>\2</h\1>\r<p class=noindent>:
"%s:^ÞtzpSectionTzp\s\+\(sectionbreak\)\s\+.*:</p>\r<h3 class=\1>\&#x3091;</h3>\r<p class=noindent>:

" possible ornaments: * &#x203b &#x2217

"drop cap

%s/^ÞtzpSectionTzp\s\+dropcap\s\+.*/ÞtzpDropCapTzp/

g/^ÞtzpDropCapTzp\$/ , +1 j

%s:^ÞtzpDropCapTzp\s*\(.\{-}[[:alnum:]]\):</p>\r<p class=noindent><span class=dropcap>\1</span>:

"

v/^ÞtzpPreformattedTzp/ s/^\([^@].\{-}\\\*\[\%(\^\|::\)\s*[^]]\{-}\)\\\\\$/\1 ÞtzpContinuationLineTzp/

g/\\\*\[\%(\^\|::\)\s*[^]]\{-}ÞtzpContinuationLineTzp\$/ .,+1 j!

%s/ÞtzpContinuationLineTzp//

"footnotes

v/^ÞtzpPreformattedTzp/ s:(†\([^()[:space:]]\+\)):<a name="callFootnote_\1" href="#footnote_\1">ÞtzpFootnoteMarkTzp\1ÞtzpFootnoteMarkEndTzp</a>:g

v/^ÞtzpPreformattedTzp/ s:\(.\)\((†\|†)\):\1\r\2:g

%s:^\((†\s*\S\+\)\s\+\(\S\):\1\r\2:

%s:^\(†)\)\s*\(\S\):\1\r\2:

%s:^(†\s*\(\S\+\)\?\s*\$:ÞtzpFootnoteEnvTzp \10:

%s:^†)\s*\$:ÞtzpFootnoteEnvTzp1:

%s/^\(ÞtzpFootnoteEnvTzp\)0\$/\1 ÞtzpUnmarkedFootnoteTzp0/

"put a ÞtzpFootnoteTzp before every footnote line
g/^ÞtzpFootnoteEnvTzp.*0\$/,/^ÞtzpFootnoteEnvTzp.*1\$/ s/^/ÞtzpFootnoteTzp/

"wrap all footnote lines from one footnote into one combined line
g/^ÞtzpFootnoteTzpÞtzpFootnoteEnvTzp.*0\$/,/^ÞtzpFootnoteTzpÞtzpFootnoteEnvTzp.*1\$/ j!

"move all the footnote combilines to the file's end
g/^ÞtzpFootnoteTzpÞtzpFootnoteEnvTzp/ m\$

"put a ÞtzpStartFootnotesTzp ahead of the first footnote combiline
/^ÞtzpFootnoteTzpÞtzpFootnoteEnvTzp/ s/^/ÞtzpStartFootnotesTzp\r/

"put a ÞtzpEndFootnotesTzp after the last footnote combiline
\$ s/^\(ÞtzpFootnoteTzpÞtzpFootnoteEnv.*\)/\1\rÞtzpEndFootnotesTzp/

"use Þtzp{Start,End}FootnotesTzp to wrap a <div>

/^ÞtzpStartFootnotesTzp/ s#^.*\$#</p>\r<div class=footnotes>\r<hr align=left width="40%"/><p>#
/^ÞtzpEndFootnotesTzp/   s#^.*\$#</p>\r</div><p>#

"use ÞtzpFootnoteTzp to un-combine the combilines into individual lines again
%s/\(.\)\(ÞtzpFootnoteTzp\)/\1\r\2/g

"do it once more to pick up adjacent ÞtzpFootnoteTzp's
%s/\(.\)\(ÞtzpFootnoteTzp\)/\1\r\2/g

"throw away each footnote's end marker: its job is done
%s/^ÞtzpFootnoteTzpÞtzpFootnoteEnv.*1\$//

"use each footnote's start marker to typeset its symbol (if any)

%s:^ÞtzpFootnoteTzpÞtzpFootnoteEnvTzp ÞtzpUnmarkedFootnoteTzp0\$:\r:

%s:^ÞtzpFootnoteTzpÞtzpFootnoteEnvTzp \(\S\+\)0\$:\r<a name="footnote_\1" href="#callFootnote_\1">ÞtzpFootnoteMarkTzp\1ÞtzpFootnoteMarkEndTzp</a>:

%s:^ÞtzpFootnoteTzp::

%s:ÞtzpFootnoteMarkTzp\(.\{-}\)ÞtzpFootnoteMarkEndTzp:\=UpcaseDigits(submatch(1)):g

"end footnotes

"%s#^:\$#</p>\r<div class=sectionbreak></div>\r<p>#

"%s#^:\([^:]\+\):#</p>\r<p class=noindent><span class=dropcap>\1</span>#

"%s#^:\s\+\(\%([0-9]\+\.\)*[0-9]\+\)\.\s#</p>\r<p class=beginsection><span class=dropcap>\1</span> #
"%s#^:\s\+\([^A-Z0-9]*[A-Z0-9]\)#</p>\r<p class=beginsection><span class=dropcap>\1</span>#

"g/^<p class=FOLLOWINGANCHOR>/,/^<\/p>/d

%s#^\s*-\{5,}\$#<hr/>#
%s#^\.\s*--\(\s.*\)\?\$#<hr noshade size="1"/>#
%s#^\.\s*==\(\s.*\)\?\$#<hr noshade size="5"/>#

"arbitrary section-break ornament

%s/^[^[:alnum:]]\+\$/ÞtzpSectionTzp break &/

g/^ÞtzpSectionTzp\s\+break\s/-1 s/^\$/ÞtzpSectionTzp blankabovebreak x/
g/^ÞtzpSectionTzp\s\+break\s/+1 s/^\$/ÞtzpSectionTzp blankbelowbreak x/

g/^ÞtzpSectionTzp\s\+blankabovebreak\s/+1 s/ÞtzpSectionTzp\s\+break\s/ÞtzpSectionTzp breakbelowblank /

%s/^ÞtzpSectionTzp\s\+blankabovebreak\s.*//

%s/^ÞtzpSectionTzp\s\+break\s//

g/^ÞtzpSectionTzp\s\+blankbelowbreak\s/-1 s/ÞtzpSectionTzp\s\+breakbelowblank\s/ÞtzpSectionTzp breakbetweenblanks /

%s/^ÞtzpSectionTzp\s\+blankbelowbreak\s.*//

%s/^ÞtzpSectionTzp\s\+breakbelowblank\s//

g/^ÞtzpSectionTzp\s\+breakbetweenblanks\s/,/./-1 j!

%s:^ÞtzpSectionTzp\s\+breakbetweenblanks\s\+\(.*\):</p>\r<p class="dinkus noindent">\1\r</p>\r<p class=noindent>:

"

if "$prevPage" != "" || "$nextPage" != ""
  1s:^:ÞtzpNavbarTzp<a href="$prevPage">previous</a>, <a href="$nextPage">next</a> page\r:
  \$s:\$:\rÞtzpNavbarTzp<a href="$prevPage">previous</a>, <a href="$nextPage">next</a> page:
endif

g/^ÞtzpNavbarTzp/ s:<a href="">\(.\{-}\)</a>:<span class=grayed>\1</span>:g

%s:^ÞtzpNavbarTzp\(.*\)\$:<div align=right><span class=navbar>[Go to \1]</span></div>:

%s:^ÞtzpSoTOCtzp\s\+\(\S\+\)\s\+\(.*\):<a href="\1">\2</a><br/>:

"empty lines are paragraph separators, but collapse adjacent empty lines first

v/./,/./-j

%s#^\$#</p>\r\r<p>#

"g/^<p>$/,+1 j!

"%s#^<p>\(\%([A-Z0-9]\+\.\)\+\)\s#<p><b>\1</b> #

v/^ÞtzpPreformattedTzp/ s#\`\`\(.\{-1,}\)\`\`#<code>\1</code>#g

v/^ÞtzpPreformattedTzp/ s#\`\(.\{-1,}\)\`#<code>\1</code>#g

g/^ÞtzpBogusEndOfFileLineTzp/d

v/^ÞtzpPreformattedTzp/ call RecognizeURLs()

g/^ÞtzpHrefTzphref=/ call CleanUpURLs()

call FindURLfootnotes()

call FindURLHs()

call RedirectIfNecessary()

%s/^ÞtzpPreformattedTzp//
%s/ÞtzpPreformattedTzp/\r/g

%s/«/\&lt;/g
%s/»/\&gt;/g
%s/Æ/\&amp;/g
%s/Ø/ /g "space is actually u+00a0

%s/ÞtzpThornTzp/Þ/g

%s/ÞtzpAEligTzp/Æ/g
%s/ÞtzpLangleLangleTzp/«/g
%s/ÞtzpOslashTzp/Ø/g
%s/ÞtzpRangleRangleTzp/»/g

"add html boilerplate and title

0i
<!DOCTYPE html>
<html lang="en">
<!--
Generated from $f by txt2page, version $ver
Copyright (C) 2010-2014 Dorai Sitaram
-->
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="$cssf" />
<title>MYTITLE</title>
</head>
<body>
<p>
.

\$a
</p>
</body>
</html>
.

exec '5,10s#^<title>MYTITLE</title>#<title>' . titleText . '</title>#'

if exists('g:redirectURL')
  5,15s#</head>#<meta http-equiv="refresh" content="1;ÞtzpRedirectURLtzp">\r\0#
  let @0 = g:redirectURL
  5,15s/ÞtzpRedirectURLtzp/\=@0/
endif

endfunc

call Txt2page()

w
EOF
}

txt2pageLoop $opts
