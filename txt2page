ver=2014-10-20 # last modified

# ds26gte@yahoo.com

test $# -ge 1 || { echo error: no argument provided; exit; }

opts=""
pdf=0
soelim=0
while test $# -gt 1
do
    if test "$1" = "-s"
    then soelim=1
    elif test "$1" = "-Tpdf"
    then pdf=1
    else opts="$opts $1"
    fi
    shift
done

f=$1

test "$f" = "--version" && { echo txt2page $ver; exit; }

test "$f" = "--help" && { echo txt2page "[-s] [-Tpdf [groff_options]] [--version|--help|<file>]"; exit; }

test -f $f || { echo error: $f does not exist; exit; }

g=${f##*/}
ext=${g##*.}

# above sets ext=$g if there is no extension, so...

test "$ext" = "$g" && ext=""

test "$ext" != "html" -a "$ext" != "ps" -a "$ext" != "pdf" ||
    { echo error: $f is a $ext file; exit; }

test "$pdf" = 1 && { exec txt2page_pdf $opts $f; exit; }

# the exit above shouldn't be needed: just being careful

g=${g%.*}

h=$g.html
cp -p $f $h

for fn in ${g}__*.${ext}; do
    if test -f $fn
    then cat $fn >> $h
    fi
done

if test -f default.css
then cssf=default.css
else
    cssf=$(ls -1 .*.css *.css 2>/dev/null|head -1)
    #cssf=$(ls -x .*.css *.css 2>/dev/null|sed -e 's/^\([^ ]*\) *.*/\1/'|head -1)
    if test -z $cssf
    then
        echo '/* insert style here */' > default.css
        cssf=default.css
    fi
fi

ex -u NONE $h <<EOF

func! SmartQuotes()
    "opening " becomes #x201c

    s:\(^\|\s\|(\|^\*\|\s\*\)":\1\&#x201c;:g

    "opening ' becomes #x2018

    s:\(^\|\s\|(\|^\*\|\s\*\)':\1\&#x2018;:g

    "closing " becomes #x201d

    s:":\&#x201d;:g

    "closing ' becomes #x2019

    s:':\&#x2019;:g

    " -- preceded by {bol, space} and
    "followed by {space, comma-and-closing-quote, eol}
    "becomes emdash

    s:\(^\|\s\|nbsp;\)--\(\s\|,\|&#x201[d9]\|\$\):\1\&#x2014;\2:g

    " -- followed by closing quote becomes emdash

    s:--\(&#x201[d9];\):\&#x2014;\1:g

    s:\(^\|\s\)-\(&\|\s*\.\?[0-9]\):\1\&#x2212;\2:g
endfunc

func! RecognizeURLs()

    s#\\\\\*\[::\s\+\(\S\{-}\)\s*\]#<a href="\1"><code>\1</code></a>#g

    s_\\\\\*\[::\s\+\(\S\{-}\)\s\+&#x201c;\(.\{-}\)&#x201d;\s*\]_<a href="\1">\2</a>_g

    s#\\\\\*\[::\s\+\(\S\{-}\)\s\+\(\S\{-}\)\s*\]#<a href="\1">\2</a>#g

    " someone@gmail.com becomes mailto:someone@gmail.com
    " -- check not already preceded by mailto:
    s#\%(mailto:\)\@<!\<[[:alnum:]]\+@[[:alnum:].]\+\.\%(ca\|com\|edu\|gov\|in\|net\|org\|us\)\>#mailto:&#g

    " evalwhen.com becomes FAKEHTTP://evalwhen.com
    " -- check not preceded by @ or ://
    s#\%(@\|://\)\@<!\<[[:alnum:].-]\+\.\%(com\|co\.[[:lower:]]\{2}\|edu\|net\|org\|se\)\>#FAKEHTTP://&#g

    " mailto:addr becomes <a href="mailto:addr">mailto:addr</a>
    s#\<mailto:\([[:alnum:]]\+@[[:alnum:].]\+[[:alpha:]]\)\>#<a href="&"><code>\1</code></a>#g

    " @twitterhandles
    s#\%([[:alnum:]]\)\@<!@\([[:alnum:]_]\{1,15}\)#*<code>@\1</code>* https://twitter.com/\1#g

    " URL becomes <a href="URL">URL</a>
    s#\<[[:alpha:]-]\+://[^[:space:]()<>\[\]]\+\%(([[:alnum:]]\+)\|/\|[^[:space:][:punct:]»]\)#<a\rÞtzpHrefTzphref="&"\r><code>&</code></a>#g

    " "./sth" becomes <a href="sth">sth</a>
    s_&#x201c;\./\(.\{-}\)&#x201d;_<a href="\1"><code>\1</code></a>_g

    " ./pathname becomes <a href="pathname">pathname</a>
    s#\%([.]\)\@<!\./\([^[:space:]()<>&]\+\)\%([[:punct:]]\)\@<!#<a href="\1"><code>\1</code></a>#g

    " FAKEHTTP has done its job by now -- remove it
    "s#FAKEHTTP://##g

    " :emoji:
    s#:\([a-z0-9_\-]\{1,32}\):#<img class="emoji" title=":\1:" alt=":\1:" src="https://assets.github.com/images/icons/emoji/\1.png" height=20 width=20 align="absmiddle"/>#g

    s#^\(\.!!\)\s\+\([^-[:space:]]\)#\1 -center \2#

    s#^\(\.!!\)\s\+-L\s#\1 -left #
    s#^\(\.!!\)\s\+-C\s#\1 -center #
    s#^\(\.!!\)\s\+-R\s#\1 -right #

    s#^\(\.!!\s\+-[leftcnrigh]\+\s\+[^[:space:]]\+\)\s*\$#\1 50#

    s#^\.!!\s\+-\([leftcnrigh]\+\)\s\+\([^[:space:]]\+\)\s\+\([0-9]\+\)#<div class=figure align="\1"><img src="\2" width="\3%" border="0" alt=""></div>#

    exec 's:<a href="\(.\{-}\)\.' . g:fileExtension . '"><code>\(.\{-}\)\.' . g:fileExtension . '</code></a>:<a href="\1.html"><code>\2.html</code></a>:g'

    exec 's:<a href="\(.\{-}\)\.' . g:fileExtension . '">:<a href="\1.html">:g'

    exec 's:<a href="\(.\{-}\)\.' . g:fileExtension . '#\(.\{-}\)"><code>\%(.\{-}\)\.' . g:fileExtension . '#\(.\{-}\)</code></a>:<a href="\1.html#\2">\3</a>:g'

    s:\(<a href="#.\{-}">\)<code>#\(.\{-}\)</code>:\1\2:g

endfunc

func! CleanUpURLs()
    s/ÞtzpHrefTzphref/ href/
    s#href="FAKEHTTP://#href="http://#
    -1,+1 jo!
    s#FAKEHTTP://##g
    s:«\(<a href.\{-}/a>\)»:\1:g
endfunc

func! FindURLHs()
    " a line that starts with <a href is a possible urlh
    v/^ÞtzpPreformattedTzp/ s/^<a href/ÞtzpPossibleURLHtzp&/

    " its previous line would contain the link text
    g/^ÞtzpPossibleURLHtzp/ -1s/\*\$/&ÞtzpURLHcontinuationLineTzp/

    %s/^ÞtzpPossibleURLHtzp//

    " unite link text and url
    g/ÞtzpURLHcontinuationLineTzp\$/ .,+1 j

    %s/ÞtzpURLHcontinuationLineTzp//

    " a line that contains an unmatched * followed by <a href is a possible urlh
    v/^ÞtzpPreformattedTzp/ s/^[^*]\+\*\s\+<a href/ÞtzpPossibleURLHtzp&/

    " if its previous line contains a *, it contains (part of) the link text
    g/^ÞtzpPossibleURLHtzp/ -1s/\*[^*]\+\$/&ÞtzpURLHcontinuationLineTzp/

    %s/^ÞtzpPossibleURLHtzp//

    " unite link text and url
    g/ÞtzpURLHcontinuationLineTzp\$/ .,+1 j

    %s/ÞtzpURLHcontinuationLineTzp//

    " replace previous link text with true link text
    v/^ÞtzpPreformattedTzp/ s#\*\([^*]\+\)\*\s*<a href="\(.\{-}\)">.\{-}</a>#<a href="\2">\1</a>#g

    " GFM-style urlhs
    " a line containing no [ followed by ](<a href= is a possible urlh

    v/^ÞtzpPreformattedTzp/ s/^[^\[\]]\+\](<a href/ÞtzpPossibleURLHtzp&/

    " its previous line contains a part of the link text
    g/^ÞtzpPossibleURLHtzp/ -1s/\[[^\[\]]\+\$/&ÞtzpURLHcontinuationLineTzp/

    %s/^ÞtzpPossibleURLHtzp//

    " unite link text and url
    g/ÞtzpURLHcontinuationLineTzp\$/ .,+1 j

    %s/ÞtzpURLHcontinuationLineTzp//

    " if image make an img element
    v/^ÞtzpPreformattedTzp/ s#!\[\([^\[\]]*\)\](<a href="\(.\{-}\)">.\{-}</a>)#<img src="\2" alt="\1">#g

    v/^ÞtzpPreformattedTzp/ s#!\[\([^\[\]]*\)\](\(\S\+\))#<img src="\2" alt="\1">#g

    " if urlh, replace link text with true link text
    v/^ÞtzpPreformattedTzp/ s#\[\([^\[\]]*\)\](<a href="\(.\{-}\)">.\{-}</a>)#<a href="\2">\1</a>#g

    " AsciiDoc-style urlhs
    v/^ÞtzpPreformattedTzp/ s#<a href=".\{-}">.\{-}</a>\[[^\]]*\$#&ÞtzpPossibleURLHtwoTzp#

    g/ÞtzpPossibleURLHtwoTzp/ +1s#^[^\[\]]*\]#ÞtzpContinuationLineTwoTzp&#

    %s/ÞtzpPossibleURLHtwoTzp\$//

    g/^ÞtzpContinuationLineTwoTzp/ .,-1 j

    %s/ÞtzpContinuationLineTwoTzp//

    v/^ÞtzpPreformattedTzp/ s#<a href="\(.\{-}\)">.\{-}</a>\[\(.\{-}\)\]#<a href="\1">\2</a>#g
endfunc

func! RedirectIfNecessary()
  v/^ÞtzpPreformattedTzp/ s#<a href="\(.\{-}\)">=REDIRECT=</a>#ÞtzpRedirectTzp{\1}#
  let redirectFoundP = 0
  g/ÞtzpRedirectTzp{.\{-}}/ let redirectFoundP = 1
  if redirectFoundP
    /ÞtzpRedirectTzp/
    norm f{lyi}
    let g:redirectURL = @0
    g/ÞtzpRedirectTzp{.\{-}}/ s#ÞtzpRedirectTzp{\(.\{-}\)}#If not redirected automatically, go to <a href="\1">\1</a>.#
  endif
endfunc

func! SubAlternate(...)
  if !exists('b:subAlternateP')
    let b:subAlternateP = 1
  endif
  if a:0
    let b:subAlternateP = 1
  else
    let b:subAlternateP = !b:subAlternateP
    return b:subAlternateP
  endif
endfunc

func! LineAsIs()
  while match(getline('.'), '^Ø*\s') > -1
    s/^\(Ø*\)\s/\1Ø/
  endwhile
  s/Ø/\&nbsp;/g
  s#\$#<br/>#
endfunc

func! VerbatimLineAsIs()
  s/\s/Ø/g
  s/\([^Ø]\)Ø\([^Ø]\)/\1 \2/g
  s/Ø/\&nbsp;/g
  s#\$#<br/>#
endfunc

func! CodeLineAsIs()
  call VerbatimLineAsIs()
  s/^/ÞtzpPreformattedTzp/
endfunc

func! Txt2page()

while 1
  if (!$soelim)
    %s/^\.\s*so\s\+\(\S\+\s\+\S\)/ÞtzpSoTOCtzp \1/
  endif
  0
  let m = search('^\.\s*so\s')
  if (m == 0)
    break
  endif
  s/^\.\s*so/ÞtzpSoDoneTzp/
  norm W
  r <cfile>
endwhile

g/^ÞtzpSoDoneTzp/d

"use unabbreviations for these rare characters if they occur verbatim in the source,
"as we'll be using these characters as temporary symbols

%s/Þ/ÞtzpThornTzp/g
%s/^ÞtzpThornTzp\(tzpSoTOCtzp\)/Þ\1/  "! see above
%s/Ø/ÞtzpOslashTzp/g
%s/Æ/ÞtzpAEligTzp/g
%s/«/ÞtzpLangleLangleTzp/g
%s/»/ÞtzpRangleRangleTzp/g

\$a
ÞtzpBogusEndOfFileLineTzp
.

"use temp symbols to stand for verbatim &<>; we'll convert them to appropriate HTML entities
"at the end

%s/&/Æ/g
%s/</«/g
%s/>/»/g

"remove all trailing spaces

%s/\s\+\$//

let titleText = "$g"
let fileStem = "$g"

let g:fileExtension = "$ext"
if g:fileExtension == ""
    let g:fileExtension = "tzpLetsNotMatchAnythingAgainstThis"
endif

0
let lastline = line('$')
while 1
    let linenum = line('.')
    if linenum > 100 || linenum == lastline
        break
    endif
    let linestr = getline('.')
    if match(linestr, '^\.\s*TH\s\+".\{-}"') > -1
        s/^\.\s*TH\s\+"\(.\{-}\)".*/.TH \1/
        break
    elseif match(linestr, '^\.\s*TH\s\+\(\S\+\)\s\+\S') > -1
        s/^\.\s*TH\s\+\(\S\+\).*/.TH \1/
        break
    endif
    norm j
endwhile

let ln = 0
while ln < 100 && ln < lastline
    let x = getline(ln)
    if match(x, '^\%(\.\s*\%(HTL\|TH\|SH\|SS\)\|#\+\)\s\+\S') > -1
        let titleText = substitute(x, '^\%(\.\s*\%(HTL\|TH\|SH\|SS\)\|#\+\)\s\+\(.\{-}\)\s*#*\$', '\1', '')
        break
    endif
    let ln+=1
endwhile

if $soelim
    g/^\.\s*TOC/ d
    g/^\.\s*NAV/ d
endif

%s/^\.\s*TOC\s*//

call SubAlternate(0)
g/^\s*::\$/ s/\$/\=SubAlternate()

g/^\s*::0\$/+1,/^\s*::1/-1 call LineAsIs()

g/^\s*::[01]/d

%s/^\.\s*nf\$/ÞtzpNoFillEnvTzp/
%s/^\.\s*fi\$/ÞtzpNoFillEnvTzp/

call SubAlternate(0)
g/^ÞtzpNoFillEnvTzp\$/ s/\$/\=SubAlternate()

if (b:subAlternateP != 1)
      \$a
  ÞtzpNoFillEnvTzp1
.
endif

g/^ÞtzpNoFillEnvTzp0/+1,/^\s*ÞtzpNoFillEnvTzp1/-1 call VerbatimLineAsIs()

g/^\s*ÞtzpNoFillEnvTzp[01]/d

"code display

%s/^\.\s*E[XE]\$/\`\`\`/

%s/^\s*\`\`\`\s*[[:alpha:]]\+\$/ÞtzpListingTzp scheme/
%s/^\s*\`\`\`\$/ÞtzpListingTzp/

if executable('lisphilite')
  g/^ÞtzpListingTzp scheme/+1,/^ÞtzpListingTzp/-1 s/«/</g
  g/^ÞtzpListingTzp scheme/+1,/^ÞtzpListingTzp/-1 s/»/>/g
  g/^ÞtzpListingTzp scheme/+1,/^ÞtzpListingTzp/-1 s/Æ/\&/g
  g/^ÞtzpListingTzp scheme/+1,/^ÞtzpListingTzp/-1 !lisphilite
endif

call SubAlternate(0)
g/^ÞtzpListingTzp/ s/\$/\=SubAlternate()

g/^ÞtzpListingTzp.*0\$/+1,/^ÞtzpListingTzp.*1\$/-1 call CodeLineAsIs()

%s#^ÞtzpListingTzp\(.*\)0\$#</p>\rÞtzpPreformattedTzp<div class="listing\1"><code>#
%s#^ÞtzpListingTzp\(.*\)1\$#ÞtzpPreformattedTzp</code></div>\r<p class=noindent>#

0
let lastline = line('$')
while 1
    let currline = line('.')
    if currline == 1
        if match(getline('.'), '^\s') > -1
            let m = 1
        else
            let m = search('^\s')
        endif
    else
        let m = search('^\s')
    endif
    if m == 0
        break
    endif
    s/\$/ÞtzpLeadingSpacesStartLineTzp/
    while 1
        if match(getline('.'), '^\$') > -1
            break
        endif
        call VerbatimLineAsIs()
        if line('.') == lastline
            break
        endif
        norm j
    endwhile
endwhile

g/ÞtzpLeadingSpacesStartLineTzp/ s#^#\r#

%s/ÞtzpLeadingSpacesStartLineTzp//

g/^\.\s*\\\"/d
g/^\.\s*HTL/d
g/^#\s\+.\{-}\s*##\$/d

v/^ÞtzpPreformattedTzp/ call SmartQuotes()

"bullet items

%s:^\*\s\+:</p><p class=bulleted><span class=bullet>\&bull;\&nbsp;</span>:

"Tables

"for every line starting with |\s, replace it with <space>ÞtzpTableLineTzp

g/^|\s/,/^[^|]/-1 s#^|\s# ÞtzpTableLineTzp#

"collapse successive ÞtzpTableLineTzps together

g/^ ÞtzpTableLineTzp/,/^\%(\$\|[^ ]\)/-1 j

"remove single space before ÞtzpTableLineTzp

%s/ \(ÞtzpTableLineTzp\)/\1/g

"enclose the collapsed ÞtzpTableLineTzp with <table> tags

%s#^ÞtzpTableLineTzp.*\$#</p>\r<div align="center">\r<table border="1" cellpadding="4">&\r</table>\r</div>\r<p>#

"precede each ÞtzpTableLineTzp with a CR

%s#ÞtzpTableLineTzp#\r&#g

"chomp the last | in each table line

g/^ÞtzpTableLineTzp/ s#\s|\$##

"replace every other | with a table-cell separator

g/^ÞtzpTableLineTzp/ s#\s|\s#</td><td>#g

"wrap each table-line with a <tr>

%s#^ÞtzpTableLineTzp\(.*\)\$#<tr><td>\1</td></tr>#

"g/^ÞtzpBogusEndOfFileLineTzp/d

"invisible anchor
%s:^\.%%\s\+\([^[:space:]()<>&#]\+\)\$:<a name="\1"></a>:

"visible anchor
%s:^\.%%%\s\+\([^[:space:]()<>&#]\+\)\$:<span class=anchor><a name="\1"></a>[\1]\&nbsp;</span>:

"sections

%s/^\.\s*TH\s\+\(.*\)\$/ÞtzpSectionTzp title \1/
%s/^\.\s*SH\s\+\(.*\)\$/ÞtzpSectionTzp 1 \1/
%s/^\.\s*SS\s\+\(.*\)\$/ÞtzpSectionTzp 2 \1/

%s/^#\s\+\(.\{-}\)\s\+#\$/ÞtzpSectionTzp title \1/
%s/^#\s\+\(.\{-}\)\s\+##\$/ÞtzpSectionTzp htmltitle \1/
%s/^##\s\+##\$/ÞtzpSectionTzp sectionbreak \1/

g/^ÞtzpSection\s\+htmltitle\s\+/d "for now

%s/^#\s\+\(.\{-}\)\s*#*\$/ÞtzpSectionTzp 1 \1/
%s/^##\s\+\(.\{-}\)\s*#*\$/ÞtzpSectionTzp 2 \1/
%s/^###\s\+\(.\{-}\)\s*#*\$/ÞtzpSectionTzp 3 \1/
%s/^####\s\+\(.\{-}\)\s*#*\$/ÞtzpSectionTzp 4 \1/
%s/^#####\s\+\(.\{-}\)\s*#*\$/ÞtzpSectionTzp 5 \1/
%s/^######\s\+\(.\{-}\)\s*#*\$/ÞtzpSectionTzp 6 \1/

g/^ÞtzpSectionTzp/,/./-1 j!

%s:^ÞtzpSectionTzp\s\+\(title\)\s\+\(.*\):</p>\r<h1 class=\1>\2</h1>\r<p class=noindent>:
%s:^ÞtzpSectionTzp\s\+\([1-6]\)\s\+\(.*\):</p>\r<h\1 class=section>\2</h\1>\r<p class=noindent>:
%s:^ÞtzpSectionTzp\s\+\(sectionbreak\)\s\+\(.*\):</p>\r<h3 class=\1>\&#x3091;</h3>\r<p class=noindent>:

" possible ornaments: * &#x203b &#x2217

"drop cap

%s/^\[===\]/ÞtzpDropCapTzp/

g/^ÞtzpDropCapTzp\$/ , /./-1 j

g/^ÞtzpDropCapTzp\s*\$/ , +1 j

%s:^ÞtzpDropCapTzp\s*\(.\{-}[[:alnum:]]\):</p>\r<p class=noindent><span class=dropcap>\1</span>:

"blockquote

%s:^»\s*:</p>\r<p class=blockquote>\r:

v/^ÞtzpPreformattedTzp/ s/^\([^@].\{-}\\\*\[\%(\^\|::\)\s*[^]]\{-}\)\\\\\$/\1 ÞtzpContinuationLineTzp/

g/\\\*\[\%(\^\|::\)\s*[^]]\{-}ÞtzpContinuationLineTzp\$/ .,+1 j!

%s/ÞtzpContinuationLineTzp//

"footnotes

v/^ÞtzpPreformattedTzp/ s:\`\@<!\[\^\(\S\+\)\]:<sup><a name="callFootnote_\1" href="#footnote_\1">\1</a></sup>:g

%s/^\.\s*F[SE]\(\s\+\S.*\)\?\$/ÞtzpFootnoteEnvTzp\1/

%s/^:+:\$/ÞtzpFootnoteEnvTzp/
%s/^:+:\s*\(\S\+\)\$/ÞtzpFootnoteEnvTzp \1/

call SubAlternate(0)
g/^ÞtzpFootnoteEnvTzp/ s/\$/\=SubAlternate()

%s/^\(ÞtzpFootnoteEnvTzp\)0\$/\1 ÞtzpUnmarkedFootnoteTzp0/

"put a ÞtzpFootnoteTzp before every footnote line
g/^ÞtzpFootnoteEnvTzp.*0\$/,/^ÞtzpFootnoteEnvTzp.*1\$/ s/^/ÞtzpFootnoteTzp/

"wrap all footnote lines from one footnote into one combined line
g/^ÞtzpFootnoteTzpÞtzpFootnoteEnvTzp.*0\$/,/^ÞtzpFootnoteTzpÞtzpFootnoteEnvTzp.*1\$/ j!

"move all the footnote combilines to the file's end
g/^ÞtzpFootnoteTzpÞtzpFootnoteEnvTzp/ m\$

"put a ÞtzpStartFootnotesTzp ahead of the first footnote combiline
/^ÞtzpFootnoteTzpÞtzpFootnoteEnvTzp/ s/^/ÞtzpStartFootnotesTzp\r/

"put a ÞtzpEndFootnotesTzp after the last footnote combiline
\$ s/^\(ÞtzpFootnoteTzpÞtzpFootnoteEnv.*\)/\1\rÞtzpEndFootnotesTzp/

"use Þtzp{Start,End}FootnotesTzp to wrap a <div>

/^ÞtzpStartFootnotesTzp/ s#^.*\$#</p>\r<div class=footnotes>\r<hr align=left width="40%"/><p>#
/^ÞtzpEndFootnotesTzp/   s#^.*\$#</p>\r</div><p>#

"use ÞtzpFootnoteTzp to un-combine the combilines into individual lines again
%s/\(.\)\(ÞtzpFootnoteTzp\)/\1\r\2/g

"do it once more to pick up adjacent ÞtzpFootnoteTzp's
%s/\(.\)\(ÞtzpFootnoteTzp\)/\1\r\2/g

"throw away each footnote's end marker: its job is done
%s/^ÞtzpFootnoteTzpÞtzpFootnoteEnv.*1\$//

"use each footnote's start marker to typeset its symbol (if any)

%s:^ÞtzpFootnoteTzpÞtzpFootnoteEnvTzp ÞtzpUnmarkedFootnoteTzp0\$:\r:

%s:^ÞtzpFootnoteTzpÞtzpFootnoteEnvTzp \(\S\+\)0\$:\r<sup><a name="footnote_\1" href="#callFootnote_\1">\1</a></sup>:

%s:^ÞtzpFootnoteTzp::

"end footnotes

"%s#^:\$#</p>\r<div class=sectionbreak></div>\r<p>#

"%s#^:\([^:]\+\):#</p>\r<p class=noindent><span class=dropcap>\1</span>#

"%s#^:\s\+\(\%([0-9]\+\.\)*[0-9]\+\)\.\s#</p>\r<p class=beginsection><span class=dropcap>\1</span> #
"%s#^:\s\+\([^A-Z0-9]*[A-Z0-9]\)#</p>\r<p class=beginsection><span class=dropcap>\1</span>#

"g/^<p class=FOLLOWINGANCHOR>/,/^<\/p>/d

%s#^\s*-\{5,}\$#<hr/>#
%s#^\.\s*--\(\s.*\)\?\$#<hr noshade size="1"/>#
%s#^\.\s*==\(\s.*\)\?\$#<hr noshade size="5"/>#

g/^[.]\@![^[:alnum:]]\+\$/ s/^.\{-}\(.\).\{-}\1/ÞtzpSectionBreakTzp&/

g/^ÞtzpSectionBreakTzp/,/./-1 j

%s:^ÞtzpSectionBreakTzp\(.*\)\$:</p>\r<p class=noindent>\1\r</p>\r<p class=noindent>:

/^\.NAV/ m \$

\$ /^\.NAV/ co 0

%s:^\.NAV.*:\r\0\r:

%s:^\.NAV\s\+\(\S\+\)\s\+\(\S\+\)\s\+\(\S\+\)\s\+\(\S\+\):ÞtzpNavbarTzp<a href="\1">previous</a>, <a href="\2">next</a> page; <a href="\3">contents</a>; <a href="\4">index</a>:
%s:^\.NAV\s\+\(\S\+\)\s\+\(\S\+\)\s\+\(\S\+\):ÞtzpNavbarTzp<a href="\1">previous</a>, <a href="\2">next</a> page; <a href="\3">contents</a>:
%s:^\.NAV\s\+\(\S\+\)\s\+\(\S\+\):ÞtzpNavbarTzp<a href="\1">previous</a>, <a href="\2">next</a> page:
%s:^\.NAV\s\+\(\S\+\):ÞtzpNavbarTzp<a href="\1">next</a> page:

g/^ÞtzpNavbarTzp/ s:<a href="_">\(.\{-}\)</a>:<span class=grayed>\1</span>:g

%s:^ÞtzpNavbarTzp\(.*\)\$:<div align=right><span class=navbar>[Go to \1]</span></div>:

%s:^ÞtzpSoTOCtzp\s\+\(\S\+\)\s\+\(.*\):<a href="\1">\2</a><br/>:

"empty lines are paragraph separators, but collapse adjacent empty lines first

v/./,/./-j

%s#^\$#</p>\r\r<p>#

"g/^<p>$/,+1 j!

"%s#^<p>\(\%([A-Z0-9]\+\.\)\+\)\s#<p><b>\1</b> #

v/^ÞtzpPreformattedTzp/ s#\`\`\(.\{-1,}\)\`\`#<code>\1</code>#g

v/^ÞtzpPreformattedTzp/ s#\`\(.\{-1,}\)\`#<code>\1</code>#g

g/^ÞtzpBogusEndOfFileLineTzp/d

%s:^\.JPEG\s:.!! :

v/^ÞtzpPreformattedTzp/ call RecognizeURLs()

g/^ÞtzpHrefTzphref=/ call CleanUpURLs()

call FindURLHs()

call RedirectIfNecessary()

%s/^ÞtzpPreformattedTzp//
%s/ÞtzpPreformattedTzp/\r/g

%s/Æ/\&amp;/g
%s/«/\&lt;/g
%s/»/\&gt;/g

%s/ÞtzpThornTzp/Þ/g
%s/ÞtzpOslashTzp/Ø/g
%s/ÞtzpAEligTzp/Æ/g
%s/ÞtzpLangleLangleTzp/«/g
%s/ÞtzpRangleRangleTzp/»/g

"add html boilerplate and title

0i
<!DOCTYPE html>
<html lang="en">
<!--
Generated from $f by txt2page, version $ver
Copyright (C) 2010-2014 Dorai Sitaram
-->
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="$cssf" />
<title>MYTITLE</title>
</head>
<body>
<p>
.

\$a
</p>
</body>
</html>
.

exec '5,10s#^<title>MYTITLE</title>#<title>' . titleText . '</title>#'

if exists('g:redirectURL')
  5,15s#</head>#<meta http-equiv="refresh" content="1;ÞtzpRedirectURLtzp">\r\0#
  let @0 = g:redirectURL
  5,15s/ÞtzpRedirectURLtzp/\=@0/
endif

endfunc

call Txt2page()

w
EOF
